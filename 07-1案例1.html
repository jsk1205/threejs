<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Three框架</title>
        <script src="https://johnson2heng.github.io/three.js-demo/lib/three.js"></script>
        <script src="https://johnson2heng.github.io/three.js-demo/lib/js/controls/OrbitControls.js"></script>
        <script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/stats.min.js"></script>
        <script src="https://johnson2heng.github.io/three.js-demo/lib/js/libs/dat.gui.min.js"></script>
			
		</script>
        <style type="text/css">
           html, body {
			   margin: 0;
			   height: 100%;
		   }
   
		   canvas {
			   display: block;
		   }
        </style>
    </head>

    <body onload="draw()">
	</body>	
       <script type="text/javascript">
       	    var renderer;
			function initRender() {
				renderer = new THREE.WebGLRenderer({antialias: true,alpha:true});
				renderer.setSize(window.innerWidth, window.innerHeight);
				//告诉渲染器需要阴影效果
				//renderer.shadowMap.enabled = true;
				//renderer.shadowMap.type = THREE.PCFSoftShadowMap; // 默认的是，没有设置的这个清晰 THREE.PCFShadowMap
				renderer.setClearColor('#fff');
				document.body.appendChild(renderer.domElement);
			}
			
			var camera;
			function initCamera(){
				camera=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,0.1,1000)
				camera.position.set(0,40,100)
				camera.lookAt(new THREE.Vector3(0,0,0))
				
			}
			
			var scene;
			function initScene(){
				scene = new THREE.Scene();
			}
			
			function initLight() {
			    //光源设置
			    var point=new THREE.PointLight(0xffffff);
			    point.position.set(400,200,300);//光源位置
			    scene.add(point);//将光源添加到场景中去
			}
			let T0 = new Date();//上次时间
			function initModel(){
			    //辅助坐标系
				var helper = new THREE.AxesHelper(50);
				scene.add(helper);
				
				let T1 = new Date();//本次时间
				let t = T1-T0;//时间差
				T0 = T1;//把本次时间赋值给上次时间
				var s = 25;
				var cube = new THREE.CubeGeometry(s, s, s);
                for(var i=0;i<3000;i++){
					var material =new THREE.MeshBasicMaterial({color:randomColor()})
					var mesh=new THREE.Mesh(cube,material)
					
					mesh.position.x = 800 * ( 2.0 * Math.random() - 1.0 );
					mesh.position.y = 800 * ( 2.0 * Math.random() - 1.0 );
					mesh.position.z = 800 * ( 2.0 * Math.random() - 1.0 );
					
					mesh.rotation.x = Math.random() * Math.PI;
					mesh.rotation.y = Math.random() * Math.PI;
					mesh.rotation.z = Math.random() * Math.PI;
					
					mesh.updateMatrix();
					
					mesh.rotateY(0.001*t);//旋转角速度0.001弧度每毫秒
					
					scene.add(mesh);

				}
			}
			
			//随机生成颜色
			function randomColor(){
				var arrHex=["0","1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d","e","f"]
				strHex='#'
				var index;
				for(var i=0;i<6;i++){
					index=Math.round(Math.random()*15)
				    // random() 方法可返回介于 0 ~ 1 之间的一个随机数。
					strHex+=arrHex[index]
				}
				return strHex
			}
			//声明raycaster和mouse变量
			
			//光线投射
			var raycaster=new THREE.Raycaster()
			var mouse=new THREE.Vector2()
			
			function onMouseClick(event){
				// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)
				mouse.x=(event.clientX/window.innerWidth)*2-1
				mouse.y=(event.clientY/window.innerHeight)*2+1
				
				// 通过摄像机和鼠标位置更新射线
				// 通过鼠标点的位置和当前相机的矩阵计算出raycaster
			    raycaster.setFromCamera(mouse,camera)	
				// 获取raycaster直线和所有模型相交的数组集合
				var intersects = raycaster.intersectObjects( scene.children );
				console.log(intersects);
				
				// for(var i=0;i<intersects.length;i++){
				// 	intersects[i].object.material.color.set(0xff0000 )
				// }
			}
			
			window.addEventListener( 'click', onMouseClick, false );
				 
			//初始化dat.GUI简化试验流程	 
			var gui;
			function initGui(){
				//声明一个保存需求修改的相关数据对象
				controls={
					
				}
				var gui=new dat.GUI()
			}
			//初始化性能插件
			var stats;
			function initStats(){
				stats=new Stats
				document.body.appendChild(stats.dom)
			}
			//用户交互插件 鼠标左键按住旋转，右键按住平移，滚轮缩放
			var controls;
			function initControls(){
				controls=new THREE.OrbitControls(camera,renderer.domElement)
				// 如果使用animate方法时，将此函数删除
				// controls.addEventListener( 'change', render );
				// 使动画循环使用时阻尼或自转 意思是否有惯性
				controls.enableDamping = true;
				//动态阻尼系数 就是鼠标拖拽旋转灵敏度
				//controls.dampingFactor = 0.25;
				//是否可以缩放
				controls.enableZoom = true;
				//是否自动旋转
				controls.autoRotate = false;
				//设置相机距离原点的最远距离
				controls.minDistance = 50;
				//设置相机距离原点的最远距离
				controls.maxDistance = 200;
				//是否开启右键拖拽
				controls.enablePan = true;
				
			}
			function render() {
			    renderer.render(scene, camera);
			}
			
			//窗口变动触发的函数
			function onWindowResize(){
				camera.aspect=window.innerWidth/window.innerHeight
				camera.updateProjectionMatrix();
				render()
				renderer.setSize(window.innerWidth,window.innerHeight)
	        }
			
			
			//更新控制器
			function animate(){
				
				// render()
				stats.update()
				//controls.update();
				requestAnimationFrame(animate)
				renderer.render(scene,camera);//执行渲染操作
				
			}
			function draw(){
				initRender();
				initScene();
				initCamera();
				initLight();
				initModel();
				initGui();
				initControls();
				initStats();
				
				animate();
				window.onresize=onWindowResize
			}
       </script>
</html>