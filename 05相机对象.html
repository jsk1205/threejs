<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three测试文件1</title>
		<style type="text/css">
			body{
				margin:0;
				padding: 0;
				overflow: hidden;
			}
		    #can{
					display: block;
				}
		</style>
		<script src="http://www.yanhuangxueyuan.com/versions/threejsR92/build/three.js"></script>
		<script src="http://www.yanhuangxueyuan.com/threejs/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<!-- <canvas id="can"></canvas> -->
		<script type="text/javascript">
			
			var scene=new THREE.Scene(); //创建场景对象
		    var geometry=new THREE.BoxGeometry(100, 100, 100);
			
			var material = new THREE.MeshLambertMaterial({
				color:0x0000ff	
			})
			
			// 创建一个矩形平面网模型，Canvas画布作为矩形网格模型的纹理贴图
			var mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh)
			
			//光源设置
			var point=new THREE.PointLight(0xffffff);
			point.position.set(400,200,300);//光源位置
			scene.add(point);//将光源添加到场景中去
			
			//环境光  依次还有 点光源 平行光 
			var ambient=new THREE.AmbientLight(0x444444);
			scene.add(ambient);
			
			//相机设置
			//正投影相机
			// var width=window.innerWidth;
			// var height=window.innerHeight
			// var k=width/height
			// var s=150 //三维场景显示控制范围系数
			
			// //创建相机对象
			// var camera=new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
			// camera.position.set(200,300,200);//设置相机位置
			// camera.lookAt(scene.position);//定义相机的位置与方向 即指向的场景对象
			
			// 正投影相机OrthographicCamera自适应渲染
			// onresize 事件会在窗口被调整大小时发生
			window.onresize=function(){
				renderer.setSize(window.innerWidth,window.innerHeight);
				// 重置相机投影的相关参数
				k = window.innerWidth/window.innerHeight;//窗口宽高比
				camera.left = -s*k;
			    camera.right = s*k;
			    camera.top = s;
			    camera.bottom = -s;
			    // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix
			    // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)
			    // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵
			    camera.updateProjectionMatrix ();
			}
			
			//  透视投影相机
			var width=window.innerWidth;
			var height=window.innerHeight
			var camera=new THREE.PerspectiveCamera(60,width/height,1,1000)
			camera.position.set(200,300,200);//设置相机位置
			camera.lookAt(scene.position);//定义相机的位置与方向 即指向的场景对象
			// 透视投影相机PerspectiveCamera自适应渲染
			// onresize 事件会在窗口被调整大小时发生
			window.onresize=function(){
			  // 重置渲染器输出画布canvas尺寸
			  renderer.setSize(window.innerWidth,window.innerHeight);
			  // 全屏情况下：设置观察范围长宽比aspect为窗口宽高比
			  camera.aspect = window.innerWidth/window.innerHeight;
			  // 渲染器执行render方法的时候会读取相机对象的投影矩阵属性projectionMatrix
			  // 但是不会每渲染一帧，就通过相机的属性计算投影矩阵(节约计算资源)
			  // 如果相机的一些属性发生了变化，需要执行updateProjectionMatrix ()方法更新相机的投影矩阵
			  camera.updateProjectionMatrix ();
			}
			
			
			//创建渲染器对象
			var renderer =new THREE.WebGLRenderer();
			renderer.setSize(width,height);//设置渲染区域尺寸
			renderer.setClearColor(0xb9d3ff,1);//设置背景颜色
			document.body.appendChild(renderer.domElement);//body元素中插入canvas对象
			//执行渲染操作  指定场景 相机作为参数
			// renderer.render(scene, camera);
			
			//鼠标操作
			function render() {
			  renderer.render(scene,camera);//执行渲染操作
			}
			render();
			var controls = new THREE.OrbitControls(camera,renderer.domElement);//创建控件对象
			controls.addEventListener('change', render);//监听鼠标、键盘事件
			
		</script>
	</body>
</html>

