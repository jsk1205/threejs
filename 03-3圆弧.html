<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three测试文件1</title>
		<style type="text/css">
			body{
				margin:0;
				padding: 0;
				overflow: hidden;
			}
		</style>
		<script src="http://www.yanhuangxueyuan.com/versions/threejsR92/build/three.js"></script>
		<script src="http://www.yanhuangxueyuan.com/threejs/examples/js/controls/OrbitControls.js"></script>
	</head>
	<body>
		<script type="text/javascript">
			var scene=new THREE.Scene(); //创建场景对象
			// console.log('打印场景API',THREE.Scene);
			console.log(scene)
			
			//创建模型
			var geometry=new THREE.Geometry(100,100,100);//创建一个立方体几何对象BoxGeometry
			// var geometry = new THREE.SphereGeometry(60, 40, 40); //球体
             
			// 绘制圆弧
			// var arc=new THREE.ArcCurve(0,0,100,0,2*Math.PI);
			//getPoints是基类Curve的方法，返回 一个 vector2对象 作为元素组成的 数 组
			// var points=arc.getPoints(50); //得到一个数
			// console.log(points)
			
			// setFromPoints方法从 points 数组 中提取数据 取出来赋值给 几何体的顶点属性vertices
			// geometry.setFromPoints(points);
			// console.log(geometry.vertices);
			
			
			//绘制直线
			// var p1 = new THREE.Vector3(50, 0, 0); //顶点1坐标
			// var p2 = new THREE.Vector3(0, 70, 0); //顶点2坐标
			//顶点坐标添加到geometry对象
			// geometry.vertices.push(p1, p2);
			
			// 绘制一条三维直线 
			var p1 = new THREE.Vector2(50, 0); //顶点1坐标
			var p2 = new THREE.Vector2(0, 70); //顶点2坐标
			
			var LineCurve = new THREE.LineCurve(p1, p2);
			var pointArr = LineCurve.getPoints(10);
			geometry.setFromPoints(pointArr);
		
			//材质对象
			var material=new THREE.LineBasicMaterial({ //材质对象
				color: 0x000000
			});
			
			//线条模型对象
			var line = new THREE.Line(geometry, material);
			scene.add(line); //线条对象添加到场景中
			
	
			
		
			
			//相机设置
			var width=window.innerWidth;//窗口宽度
			var height=window.innerHeight;//窗口高度
			var k=width/height ;//宽高比
			var s=200;//3d范围控制系数
			
			//创建相机对象
			var camera=new THREE.OrthographicCamera(-s * k, s * k, s, -s, 1, 1000);
			camera.position.set(200,300,200);//设置相机位置
			camera.lookAt(scene.position);//定义相机的位置与方向 即指向的场景对象
			
			//创建渲染器对象
			var renderer =new THREE.WebGLRenderer();
			renderer.setSize(width,height);//设置渲染区域尺寸
			renderer.setClearColor(0xb9d3ff,1);//设置背景颜色
			document.body.appendChild(renderer.domElement);//body元素中插入canvas对象
			//执行渲染操作  指定场景 相机作为参数
			// renderer.render(scene, camera);
			
			//均匀旋转
			let T0 = new Date();//上次时间
			//周期性渲染
			function render(){
				let T1 = new Date();//本次时间
				let t = T1-T0;//时间差
				T0 = T1;//把本次时间赋值给上次时间
				renderer.render(scene,camera);
				mesh.rotateY(0.001*t);
				requestAnimationFrame(render);//请求再次执行渲染函数render
			}
			// setInterval("render()",20);
			render();
			
			//requestAnimationFrame 和setInterval  一样都是window对象的方法
			//requestAnimationFrame 何时执行由浏览器决定  即调用render() 即可产生渲染效果
			// setInterval 由自己设定时间产生渲染效果
			
			
			
			
		</script>
	</body>
</html>
